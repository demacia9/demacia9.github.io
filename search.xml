<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web服务器—nginx与tomcat</title>
      <link href="/2023/09/26/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2023/09/26/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="1、Nginx介绍"><a href="#1、Nginx介绍" class="headerlink" title="1、Nginx介绍"></a>1、Nginx介绍</h2><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。和apache一样，都是web服务器软件，因为其性能优异，所以被广大运维喜欢。又因为nginx是一个轻量级的web服务器，相比apache来说<strong>资源消耗更低</strong>。</p><p>延伸版本：<strong>tengine（淘宝）、openresrt（章亦春）等</strong></p><ul><li><a href="http://nginx.org/">http://nginx.org</a> 官网</li><li><a href="http://www.nginx.cn/doc/index.html">http://www.nginx.cn/doc/index.html</a> 中文文档</li></ul><p><strong>最近大事记：</strong></p><p>锤子科技在 T2 鸟巢发布会上将门票收入捐赠给了 OpenResty 开源项目<br>OpenResty(又称：ngx_openresty) 是一个基于 NGINX 的可伸缩的 Web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块</p><h3 id="一、为什么选择Nginx"><a href="#一、为什么选择Nginx" class="headerlink" title="一、为什么选择Nginx"></a>一、为什么选择Nginx</h3><p>Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:</p><p>作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.</p><p>作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。</p><p>作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。</p><p>Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。</p><h3 id="二、Nginx和Apache对比"><a href="#二、Nginx和Apache对比" class="headerlink" title="二、Nginx和Apache对比"></a>二、Nginx和Apache对比</h3><ul><li>静态文件处理能力：nginx高于apache</li><li>资源消耗：nginx优于apache,因为nginx是异步处理模型，只需要几个进程就能够处理大量在线请求，而apache 2.4仍然是进程模型或者线程模型，即仍然采用大量线程来处理大量在线请求。</li><li>Apache支持的模块很多，而且也比较稳定。而nginx由于出现的比较晚，所以在这方面可能比不上Apache。</li><li>nginx本身就是一个反向代理服务器，而且支持7层负载均衡。</li><li>nginx处理动态页面很鸡肋，一般只用与处理静态页面和反向代理。</li></ul><h2 id="2、Nginx的安装部署"><a href="#2、Nginx的安装部署" class="headerlink" title="2、Nginx的安装部署"></a>2、Nginx的安装部署</h2><h3 id="一、nginx源码下载"><a href="#一、nginx源码下载" class="headerlink" title="一、nginx源码下载"></a>一、nginx源码下载</h3><p><strong>官网：</strong><a href="http://nginx.org/">http://nginx.org/</a></p><p><strong>源码包：</strong> nginx-1.19.3.tar.gz</p><p><strong>源码包下载：</strong> wget <a href="http://nginx.org/download/nginx-1.19.3.tar.gz">http://nginx.org/download/nginx-1.19.3.tar.gz</a> -P &#x2F;usr&#x2F;src</p><h3 id="二、nginx安装"><a href="#二、nginx安装" class="headerlink" title="二、nginx安装"></a>二、nginx安装</h3><pre><code>2.1、下载nginx源码包[root@zutuanxue ~]# wget http://nginx.org/download/nginx-1.19.3.tar.gz -P /usr/src[root@zutuanxue src]# cd /usr/src2.2、安装nginx依赖包[root@zutuanxue ~]# yum -y install gcc pcre-devel zlib-devel  - gcc: 源码编译工具   - pcre-devel： nginx url_rewrite 功能提供包   - zlib-devel： nginx 压缩功能提供包2.3、解压nginx源码，并进入源码包[root@zutuanxue src]# tar xf nginx-1.19.3.tar.gz[root@zutuanxue src]# cd nginx-1.19.32.4、配置nginx源码[root@zutuanxue nginx-1.19.3]# ./configure --prefix=/usr/local/nginx    配置目的：      1）检查环境 是否 满足安装条件     依赖解决      2）指定安装方式    配置文件   命令文件  各种文件放哪里   开启模块功能【内置模块  三方模块】      3）指定软件安装在那里2.5、编译nginx源码[root@zutuanxue nginx-1.19.3]# make -j42.6、安装nginx[root@zutuanxue nginx-1.19.3]# make install</code></pre><h3 id="三、nginx相关目录"><a href="#三、nginx相关目录" class="headerlink" title="三、nginx相关目录"></a>三、nginx相关目录</h3><p>nginx path prefix: “&#x2F;usr&#x2F;local&#x2F;nginx”</p><p>nginx binary file: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx”</p><p>nginx modules path: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;modules”</p><p>nginx configuration prefix: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf”</p><p>nginx configuration file: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf”</p><p>nginx pid file: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid”</p><p>nginx error log file: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;error.log”</p><p>nginx http access log file: “&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log”</p><h3 id="四、nginx启动管理"><a href="#四、nginx启动管理" class="headerlink" title="四、nginx启动管理"></a>四、nginx启动管理</h3><p>配置文件测试：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t</p><p>Nginx启动：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</p><p>Nginx关闭：killall –s QUIT nginx</p><h3 id="五、nginx启动测试"><a href="#五、nginx启动测试" class="headerlink" title="五、nginx启动测试"></a>五、nginx启动测试</h3><p>nginx安装完毕，接下来就可以启动nginx了，nginx启动后如何测试nginx的启动状态呢？可以通过以下三种方式去测试，这个可以根据自己的习惯选择一种测试就行了。</p><ul><li>使用netsata命令查看启动端口<br>[root@zutuanxue ~]# netstat –ntpl</li><li>使用losf命令查看启动端口<br>[root@zutuanxue ~]# lsof -i :80</li><li>使用文本浏览器访问nginx默认网站<br>[root@zutuanxue ~]# elinks <a href="http://ip/">http://IP</a></li></ul><p>测试页面内容如下</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105516493.png" alt="nginx默认网站页.png"></p><h2 id="3、Nginx的配置文件"><a href="#3、Nginx的配置文件" class="headerlink" title="3、Nginx的配置文件"></a>3、Nginx的配置文件</h2><h3 id="一、默认网站"><a href="#一、默认网站" class="headerlink" title="一、默认网站"></a>一、默认网站</h3><pre><code>server &#123;    listen       80;    server_name  localhost;    location / &#123;        root   html;        index  index.html index.htm;        #支持目录浏览         autoindex  on;    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;</code></pre><h3 id="二、访问控制"><a href="#二、访问控制" class="headerlink" title="二、访问控制"></a>二、访问控制</h3><pre><code>location /a &#123;    autoindex on;    allow 192.168.12.0/24;    deny all;    #基于客户端IP做过滤，符合条件的允许访问，不符合的返回404；    if ( $remote_addr !~ &quot;192.168.12&quot; ) &#123;          #return 404;          return http://book.ayitula.com;             &#125;    &#125;</code></pre><h3 id="三、登陆验证"><a href="#三、登陆验证" class="headerlink" title="三、登陆验证"></a>三、登陆验证</h3><pre><code>location /c &#123;    auth_basic &quot;登陆验证&quot;;    auth_basic_user_file /etc/nginx/htpasswd;&#125;</code></pre><h3 id="四、日志管理"><a href="#四、日志管理" class="headerlink" title="四、日志管理"></a>四、日志管理</h3><p>Nginx访问日志主要有两个参数控制</p><p>log_format #用来定义记录日志的格式（可以定义多种日志格式，取不同名字即可）</p><p>access_log #用来指定日至文件的路径及使用的何种日志格式记录日志</p><p>access_log logs&#x2F;access.log main;</p><pre><code>log_format格式变量：    $remote_addr  #记录访问网站的客户端地址    $remote_user  #远程客户端用户名    $time_local  #记录访问时间与时区    $request  #用户的http请求起始行信息    $status  #http状态码，记录请求返回的状态码，例如：200、301、404等    $body_bytes_sent  #服务器发送给客户端的响应body字节数    $http_referer  #记录此次请求是从哪个连接访问过来的，可以根据该参数进行防盗链设置。    $http_user_agent  #记录客户端访问信息，例如：浏览器、手机客户端等    $http_x_forwarded_for  #当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置</code></pre><p>自定义一个json格式的访问日志</p><pre><code>log_format main_json &#39;&#123;&quot;@timestamp&quot;:&quot;$time_local&quot;,&#39;&#39;&quot;client_ip&quot;: &quot;$remote_addr&quot;,&#39;&#39;&quot;request&quot;: &quot;$request&quot;,&#39;&#39;&quot;status&quot;: &quot;$status&quot;,&#39;&#39;&quot;bytes&quot;: &quot;$body_bytes_sent&quot;,&#39;&#39;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;,&#39;&#39;&quot;referer&quot;: &quot;$http_referer&quot;&#39;&#39;&#125;&#39;;access_log logs/access_json.log main_json;</code></pre><h3 id="五、日志截断"><a href="#五、日志截断" class="headerlink" title="五、日志截断"></a>五、<strong>日志截断</strong></h3><pre><code>mv access.log access.log.0killall -USR1 \`cat master.nginx.pid\`sleep 1gzip access.log.0</code></pre><h3 id="六、防盗链"><a href="#六、防盗链" class="headerlink" title="六、防盗链"></a>六、防盗链</h3><pre><code>location /images/ &#123;alias /data/images/;valid_referers none blocked *.ayitula.com;    if ($invalid_referer) &#123;    rewrite ^/      http://www.ayitula.com/daolian.gif;    #return 403;    &#125;&#125;</code></pre><h2 id="4、反向代理"><a href="#4、反向代理" class="headerlink" title="4、反向代理"></a>4、反向代理</h2><h3 id="一、代理介绍"><a href="#一、代理介绍" class="headerlink" title="一、代理介绍"></a>一、代理介绍</h3><p>代理在网络中使用是比较常见的，比如我们说的最多的就是翻墙软件，比如ss、蓝灯等这些大家常用的软件，他们就是能改代理大家访问国内无法访问的一些国外网站，比如facebook、YouTube等网站。其原理也比较简单：</p><p>1）用户将请求发给代理服务器</p><p>2）代理服务器代用户去访问数据</p><p>3）代理服务器将数据给用户</p><p><strong>正常没有代理情况上网</strong></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105139047.png" alt="反代1.png"></p><p><strong>代理服务器场景</strong></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105146133.png" alt="反代2.png"></p><p><strong>代理服务器扮演的就是一个中间人的角色。</strong></p><p>代理分为正向代理和反向代理两种类型：</p><p>正向代理：代理用户访问其他网站，比如ss，蓝灯。</p><p>反向代理：用来发布服务器，比如nginx</p><p>树明主要给大家介绍的是反向代理，使用反向代理发布公司的站点。**(国家严厉打击私单乱建翻墙代理服务器)**</p><h3 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h3><p>1）堡垒机：堡垒机承担所有的外部访问，保护后端服务器的安全</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105157770.png" alt="反代堡垒机.png"></p><p>2）业务发布服务器：将多个服务器通过虚拟主机的方式发布到公网</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105225160.png" alt="反代发布服务器.png"></p><p>3）缓存服务器：CDN加速<br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105185130.png" alt="反代缓存服务器.png"></p><h3 id="三、反向代理原理"><a href="#三、反向代理原理" class="headerlink" title="三、反向代理原理"></a>三、反向代理原理</h3><p>\1) 客户端通过浏览器 发起请求   代理服务器</p><p>2）代理服务器   接受请求</p><p>\3) 代理服务器   发起请求   业务服务器</p><p>4）业务服务器  接受请求</p><p>5）业务服务器  处理请求</p><p>\6) 业务服务器  响应请求   代理服务器</p><p>7）代理服务器  响应请求  客户端</p><p>8）客户端通过浏览器渲染请求并展示给用户</p><h3 id="四、反向代理实现"><a href="#四、反向代理实现" class="headerlink" title="四、反向代理实现"></a>四、反向代理实现</h3><p><strong>proxy_pass: nginx反向代理指令</strong></p><p><strong>反向代理实现</strong></p><p>location &#x2F; {</p><p>index index.php index.html index.htm; #定义首页索引文件的名称</p><p>proxy_pass <a href="http://mysvr/">http://mysvr</a> ;#请求转向mysvr 定义的服务器列表</p><p>}</p><p><strong>反向代理优化</strong></p><pre><code>proxy_set_header Host $host;   #修改请求头，添加Host字段proxy_set_header X-Real-IP $remote_addr;   #修改请求头，添加X-Real-IP字段proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   #修改请求头，添加X-Forwarded-For字段client_max_body_size 10m;    #允许客户端请求的最大单文件字节数client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间\(代理连接超时\)proxy_send_timeout 90;        #后端服务器数据回传时间\(代理发送超时\)proxy_read_timeout 90;         #连接成功后，后端服务器响应时间\(代理接收超时\)proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传</code></pre><h2 id="5、Nginx的优化"><a href="#5、Nginx的优化" class="headerlink" title="5、Nginx的优化"></a>5、Nginx的优化</h2><h3 id="一、调优的必要性"><a href="#一、调优的必要性" class="headerlink" title="一、调优的必要性"></a>一、调优的必要性</h3><p>在聊调优之前，我们先要知道为何调优，业务运行和调优的关系。</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/12/6/1607251234038.png" alt="42967083431970b0eb40b3949278a0d1.png"></p><p>业务运行：线上业务正常运行，承载了公司业务。<br>监控业务：通过监控业务对线上业务进行监控，及时发现问题。<br>优化业务：通过监控分析，发现业务问题或者瓶颈，及时对业务或者软件就行调整、优化。<br>测试优化：优化完成后，需要对现有的优化进行测试，保证业务在当前优化模式中稳定、高效，能够解决当前问题。<br>这就是业务运行的一个流程，也是我们保证业务稳定、高效、高可用的运维之道。</p><h3 id="二、调优的维度和见解分歧"><a href="#二、调优的维度和见解分歧" class="headerlink" title="二、调优的维度和见解分歧"></a>二、调优的维度和见解分歧</h3><p> 调优类的文章是最难写的，因为我只能告诉你调优的选项，无法告诉你具体的阈值，因为不同的业务运行在不同的机器，所消耗的资源是不同的；又因为场景不同，对应的调优项及阈值是千变万化的，就好比你和你上铺的兄弟都是感冒了，去医院看病开的药却是截然不同的。正是如此，才会出现当很多人看到调优的文章，看到了具体的调优项或者阈值就会浮现出两个字，我不好意思说，配个图吧！大家意会就好。</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/12/6/1607251822347.png" alt="28a4aaa7cf00a2483492b17857a75176.png"></p><h3 id="Nginx跳跃"><a href="#Nginx跳跃" class="headerlink" title="Nginx跳跃"></a>Nginx跳跃</h3><h4 id="1、并发优化"><a href="#1、并发优化" class="headerlink" title="1、并发优化"></a>1、并发优化</h4><p>nginx工作模式：主进程+工作进程</p><pre><code>启动工作进程数量worker_processes  4;#指定运行的核的编号，采用掩码的方式设置编号worker_cpu_affinity   0001 0010 0100 1000;events &#123;单个工作进程维护的请求队列长度    worker_connections  1024;&#125;</code></pre><h4 id="2、长连接"><a href="#2、长连接" class="headerlink" title="2、长连接"></a>2、长连接</h4><p>减少服务器维护因为与客户端建立http连接产生的大量tcp三次握手四次断开的开销</p><pre><code>keepalive_timeout  0;  0代表关闭#keepalive_timeout  100;#keepalive_requests 8192;</code></pre><h4 id="3、压缩"><a href="#3、压缩" class="headerlink" title="3、压缩"></a>3、压缩</h4><p>降低传输时间，增加用户体验度；降低公司带宽费用。</p><pre><code>gzip  on;gzip_proxied any;gzip_min_length 1k;gzip_buffers 4 8k;gzip_comp_level 6;gzip_types text/plain text/css application/x-javascript application/javascript application/xml;    # 开启gzip    gzip off;    #Nginx做为反向代理的时候启用：    off – 关闭所有的代理结果数据压缩    expired – 如果header中包含”Expires”头信息，启用压缩    no-cache – 如果header中包含”Cache-Control:no-cache”头信息，启用压缩    no-store – 如果header中包含”Cache-Control:no-store”头信息，启用压缩    private – 如果header中包含”Cache-Control:private”头信息，启用压缩    no_last_modified – 启用压缩，如果header中包含”Last_Modified”头信息，启用压缩    no_etag – 启用压缩，如果header中包含“ETag”头信息，启用压缩    auth – 启用压缩，如果header中包含“Authorization”头信息，启用压缩    any – 无条件压缩所有结果数据    gzip_proxied any;    # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩    gzip_min_length 1k;    # gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明    gzip_comp_level 1;    # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;    # 增加响应头”Vary: Accept-Encoding”    # 是否在http header中添加Vary: Accept-Encoding，建议开启    gzip_vary on;    # 禁用IE 6 gzip    gzip_disable &quot;MSIE [1-6]\.&quot;;    # 设置压缩所需要的缓冲区大小         gzip_buffers 32 4k;    # 设置gzip压缩针对的HTTP协议版本    gzip_http_version 1.0;</code></pre><h4 id="4、静态缓存"><a href="#4、静态缓存" class="headerlink" title="4、静态缓存"></a>4、静态缓存</h4><p>将部分数据缓存在用户本地磁盘，用户加载时，如果本地和服务器的数据一致，则从本地加载。提升用户访问速度，提升体验度。节省公司带宽成本。</p><pre><code>expires指令：开启缓存并指定静态缓存时间location ~*  \.(png|gif)$ &#123;              expires 1h;         &#125;</code></pre><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="1、Tomcat的安装部署"><a href="#1、Tomcat的安装部署" class="headerlink" title="1、Tomcat的安装部署"></a>1、Tomcat的安装部署</h2><h3 id="一、下载软件包"><a href="#一、下载软件包" class="headerlink" title="一、下载软件包"></a>一、下载软件包</h3><p>tomcat：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.31/bin/apache-tomcat-9.0.31.zip">https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.31/bin/apache-tomcat-9.0.31.zip</a></p><p>jdk：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p><p>如何想使用tomcat9的话，官方要求JRE的版本必须是8以上的，所以在安装之前，我们需要确认一下本机的版本,如果满足需求的话可以直接安装tomcat</p><h3 id="二、安装JDK"><a href="#二、安装JDK" class="headerlink" title="二、安装JDK"></a>二、安装JDK</h3><pre><code># 1、查看当前是否安装过jdk[root@zutuanxue ~]# java -versionbash: java: 未找到命令...文件搜索失败: Cannot update read-only repo#系统提示没有找到命令，意味着没有安装相关软件包，所以我们要安装# 2、安装jdk[root@zutuanxue ~]# rpm -ivh jdk-13.0.2_linux-x64_bin.rpm 警告：jdk-13.0.2_linux-x64_bin.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID ec551f03: NOKEYVerifying...                          ################################# [100%]准备中...                          ################################# [100%]正在升级/安装...   1:jdk-13.0.2-2000:13.0.2-ga        ################################# [100%]# 3、验证：安装完成后再次查看[root@zutuanxue ~]# java -versionjava version &quot;13.0.2&quot; 2020-01-14Java(TM) SE Runtime Environment (build 13.0.2+8)#java的运行环境，也叫jreJava HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing) #JVM java的虚拟机，可以使Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的字节码就可以了，这样就可以在多种平台上不加修改地运行。很多语言都采用了这种类似的思路，才使得他们具有可移植性，比如说python</code></pre><h3 id="三、安装Tomcat"><a href="#三、安装Tomcat" class="headerlink" title="三、安装Tomcat"></a>三、安装Tomcat</h3><pre><code># 1、tomcat 安装我们可以看到tomcat软件包的名称包含有apache字样，原因很简单，它是由apache资助的项目[root@zutuanxue ~]# unzip apache-tomcat-9.0.31.zip -d /opt/[root@zutuanxue ~]# cd /opt/[root@zutuanxue opt]# mv apache-tomcat-9.0.31 tomcat1解压完成，改个名就可以使用了，因为tomcat是一个二进制包，什么意思呢？就类似于我们下载游戏的时候的硬盘版，什么是硬盘版？解压就能玩，所以这个tomcat我们就压之后就可以使用了，不需要安装。[root@zutuanxue bin]# sh startup.sh Cannot find ./catalina.shThe file is absent or does not have execute permissionThis file is needed to run this program# 2、启动tomcat  ## tomcat启动命令目录[root@zutuanxue bin]# pwd/opt/tomcat1/bin  ## 启动tomcat[root@zutuanxue bin]# chmod +x catalina.sh [root@zutuanxue bin]# sh startup.sh Using CATALINA_BASE:   /opt/tomcat1Using CATALINA_HOME:   /opt/tomcat1Using CATALINA_TMPDIR: /opt/tomcat1/tempUsing JRE_HOME:        /usrUsing CLASSPATH:       /opt/tomcat1/bin/bootstrap.jar:/opt/tomcat1/bin/tomcat-juli.jarTomcat started.[root@zutuanxue webapps]# netstat -antp | grep javatcp6       0      0 127.0.0.1:8005          :::*                    LISTEN      46987/java          tcp6       0      0 :::8080                 :::*                    LISTEN      46987/java    tomcat的两个端口8005 是关闭tomcat使用的端口，可以使用telnet serverip 8005 然后输入大写的SHUTDOWN关闭tomcat，所以建议更改端口 或者把引号中了命令改成不容易记忆的，个人推荐改命令，因为改端口没有告诉负责网络安全的同事就会给你屏蔽掉………8080 连接端口8009 AJP协议使用的端口，tomcat的优势是处理jsp页面 但是对于图片，静态页面处理能力特别差，相对于apache来说，那么这个时候怎么办 做个分流 jsp页面由tomcat完成，静态的页面 图片由AJP来完成，AJP是定向包协议 使用二进制格式来传输可读性文本，在server.xml配置文件中默认不生效</code></pre><p><strong>访问默认首页</strong> <a href="http://localhost:8080/">http://localhost:8080</a><br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/19/1603105819709.png" alt="tomcat默认页.png"></p><p>注意: tomcat的访问端口是8080</p><pre><code>提示：如果之前系统中安装过java环境的话，可能会出现即便安装完成新的jdk之后，使用java -version命令所查询的结果依然是老版本的，这个问题是由于环境变量引起的，所以需要修改环境变量设置文件[root@zutuanxue ~]# vim /root/.bash_profile #####javaJAVA_HOME=/usr/java/jdk-13.0.2#对应自己安装的版本PATH=$JAVA_HOME/bin:$PATH:$HOME/binCLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jarexport PATH JAVA_HOME CLASSPATH CATALINA_HOME</code></pre><h2 id="2、-目录与配置文件"><a href="#2、-目录与配置文件" class="headerlink" title="2、 目录与配置文件"></a>2、 目录与配置文件</h2><h3 id="一、Tomcat目录说明"><a href="#一、Tomcat目录说明" class="headerlink" title="一、Tomcat目录说明"></a>一、Tomcat目录说明</h3><p><strong>tomcat主目录</strong></p><pre><code>bin：命令，存放不同平台上启动或关闭的脚本BUILDING.txt&amp;RUNNING.txt：使用文档，告诉用户如何搭建conf：各种全局配置文件，最主要的是server.xml和web.xmlCONTRIBUTING.md：捐赠lib：tomcat需要用到的库，主要是各种jar包LICENSE：许可logs：存放tomcat的日志NOTICE：通知信息README.md：读我文档RELEASE-NOTES：版本信息temp：临时文件  webapps：tomcat的web发布目录，类似于nginx或者apache的html目录  work：tomcat的工作目录，存放的是jsp编译后产生的.class文件及.java文件。清空work目录，然后重启tomcat，可以达到清除缓存的作用。</code></pre><p><strong>bin目录</strong></p><pre><code>bin目录下的文件主要有两类，一个是Linux使用的.sh结尾的文件，另外一个是windows使用的.bat结尾的文件，catalinatomcat的设置脚本，也可以启动&amp;关闭tomcat[root@zutuanxue bin]# sh catalina.sh helpUsing CATALINA_BASE:   /opt/tomcat1Using CATALINA_HOME:   /opt/tomcat1Using CATALINA_TMPDIR: /opt/tomcat1/tempUsing JRE_HOME:        /usrUsing CLASSPATH:       /opt/tomcat1/bin/bootstrap.jar:/opt/tomcat1/bin/tomcat-juli.jarUsage: catalina.sh ( commands ... )commands:  debug             Start Catalina in a debugger  debug -security   Debug Catalina with a security manager  jpda start        Start Catalina under JPDA debugger  run               Start Catalina in the current window  run -security     Start in the current window with security manager  start             Start Catalina in a separate window  start -security   Start in a separate window with security manager  stop              Stop Catalina, waiting up to 5 seconds for the process to end  stop n            Stop Catalina, waiting up to n seconds for the process to end  stop -force       Stop Catalina, wait up to 5 seconds and then use kill -KILL if still running  stop n -force     Stop Catalina, wait up to n seconds and then use kill -KILL if still running  configtest        Run a basic syntax check on server.xml - check exit code for result  version           What version of tomcat are you running?Note: Waiting for the process to end and use of the -force option require that $CATALINA_PID is defined[root@zutuanxue bin]# sh catalina.sh stop[root@zutuanxue bin]# sh catalina.sh helpstartup启动脚本shutdown关闭脚本</code></pre><p><strong>conf目录</strong></p><pre><code>这个目录下主要存放的是与tomcat设置相关的文件，常用的配置文件主要包含server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码 web.xml可以设置tomcat支持的文件类型 context.xml可以用来配置数据源之类的 tomcat-users.xml用来配置管理tomcat的用户与权限 Catalina此目录下可以设置默认加载的项目 </code></pre><p><strong>webapps目录</strong></p><pre><code>ROOTtomcat默认的页面docs使用说明文档examples例子--tomcat首页中的examples按钮对应的内容host-manager首页Host Manager按钮对应的内容manager  首页 Manager App按钮对应的内容</code></pre><h3 id="二、Tomcat相关配置文件简介"><a href="#二、Tomcat相关配置文件简介" class="headerlink" title="二、Tomcat相关配置文件简介"></a>二、Tomcat相关配置文件简介</h3><p><strong>server.xml</strong></p><table><thead><tr><th>元素名</th><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>server</td><td>port</td><td>指定一个端口，这个端口负责监听关闭tomcat的请求</td></tr><tr><td></td><td>shutdown</td><td>指定向端口发送的命令字符串</td></tr><tr><td>service</td><td>name</td><td>指定service的名字</td></tr><tr><td>Connector(表示客户端和service之间的连接)</td><td>port</td><td>指定服务器端要创建的端口号，并在这个断口监听来自客户端的请求</td></tr><tr><td></td><td>minProcessors</td><td>服务器启动时创建的处理请求的线程数</td></tr><tr><td></td><td>maxProcessors</td><td>最大可以创建的处理请求的线程数</td></tr><tr><td></td><td>enableLookups</td><td>如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</td></tr><tr><td></td><td>redirectPort</td><td>指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号</td></tr><tr><td></td><td>acceptCount</td><td>指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理</td></tr><tr><td></td><td>connectionTimeout</td><td>指定超时的时间数(以毫秒为单位)</td></tr><tr><td>Engine(表示指定service中的请求处理引擎，接收和处理来自Connector的请求)</td><td>defaultHost</td><td>指定缺省的处理请求的主机名，它至少与其中的一个host元素的name属性值是一样的</td></tr><tr><td>Context(表示一个web应用程序，通常为WAR文件，关于WAR的具体信息见servlet规范)</td><td>docBase</td><td>应用程序的路径或者是WAR文件存放的路径</td></tr><tr><td></td><td>path</td><td>表示此web应用程序的url的前缀，这样请求的url为<a href="http://localhost:8080/path/">http://localhost:8080/path/</a></td></tr><tr><td></td><td>reloadable</td><td>这个属性非常重要，如果为true，则tomcat会自动检测应用程序的&#x2F;WEB-INF&#x2F;lib 和&#x2F;WEB-INF&#x2F;classes目录的变化，自动装载新的应用程序，我们可以在不重起tomcat的情况下改变应用程序</td></tr><tr><td>host(表示一个虚拟主机)</td><td>name</td><td>指定主机名</td></tr><tr><td></td><td>appBase</td><td>应用程序基本目录，即存放应用程序的目录</td></tr><tr><td></td><td>unpackWARs</td><td>如果为true，则tomcat会自动将WAR文件解压，否则不解压，直接从WAR文件中运行应用程序</td></tr><tr><td>Logger(表示日志，调试和错误信息)</td><td>className</td><td>指定logger使用的类名，此类必须实现org.apache.catalina.Logger 接口</td></tr><tr><td></td><td>prefix</td><td>指定log文件的前缀</td></tr><tr><td></td><td>suffix</td><td>指定log文件的后缀</td></tr><tr><td></td><td>timestamp</td><td>如果为true，则log文件名中要加入时间，如下例:localhost_log.004-mm-dd.txt</td></tr><tr><td>Realm(表示存放用户名，密码及role的数据库)</td><td>className</td><td>指定Realm使用的类名，此类必须实现org.apache.catalina.Realm接口</td></tr><tr><td>Valve(功能与Logger差不多，其prefix和suffix属性解释和Logger 中的一样)</td><td>className</td><td>指定Valve使用的类名，如用org.apache.catalina.valves.AccessLogValve类可以记录应用程序的访问信息</td></tr><tr><td></td><td>directory</td><td>指定log文件存放的位置</td></tr><tr><td></td><td>pattern</td><td>有两个值，common方式记录远程主机名或ip地址，用户名，日期，第一行请求的字符串，HTTP响应代码，发送的字节数。combined方式比common方式记录的值更多</td></tr></tbody></table><p><strong>web.xml</strong></p><p>默认Web应用的首页文件的设置</p><p>报错文件的设置</p><p>session 会话过期时间的设置,单位是分钟</p><p>servlet的设置(Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。)</p><p><strong>tomcat-users.xml</strong></p><p>管理用户配置文件</p><p>rolename 定义角色，不同的角色管理权限不同，相当于组</p><pre><code>manager-gui允许访问html接口(即URL路径为/manager/html/*)manager-script允许访问纯文本接口(即URL路径为/manager/text/*)manager-jmx允许访问JMX代理接口(即URL路径为/manager/jmxproxy/*)manager-status允许访问Tomcat只读状态页面(即URL路径为/manager/status/*)admin-gui 允许访问html管理界面admin-script 允许访问文本管理界面</code></pre><p>user 定义用户名</p><pre><code>username定义用户名password设置密码roles属于那些角色/组</code></pre><h2 id="3、Tomcat发布页面"><a href="#3、Tomcat发布页面" class="headerlink" title="3、Tomcat发布页面"></a>3、Tomcat发布页面</h2><h3 id="一、静态页面"><a href="#一、静态页面" class="headerlink" title="一、静态页面"></a>一、静态页面</h3><h4 id="①访问tomcat网站管理页面"><a href="#①访问tomcat网站管理页面" class="headerlink" title="①访问tomcat网站管理页面"></a>①访问tomcat网站管理页面</h4><p>打开浏览器，在地址栏中输入 <a href="http://localhost:8080/">http://localhost:8080</a><br>看到如下页面，该页面是tomcat的默认网站，同时还提供了以下功能</p><ul><li>server status 查看服务器的状态，包括linux主机的信息，tomcat的版本信息，资源使用情况等</li><li>manager app 管理网站</li><li>host manager 虚拟主机的管理</li></ul><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160256413.png" alt="image20200312154145218.png"></p><p>默认使用这三个功能需要提供账号密码，如果没有可以采用以下的方式去修改配置文件，设置用以访问的账号密码。</p><p>在提示登录的界面点击取消，会看到提示</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160330788.png" alt="image20200312154227858.png"></p><pre><code>[root@zutuanxue ~]# vim /opt/tomcat1/conf/tomcat-users.xml &lt;role rolename=&quot;manager-gui&quot;/&gt;  &lt;role rolename=&quot;manager-script&quot;/&gt;  &lt;role rolename=&quot;manager-jmx&quot;/&gt;  &lt;role rolename=&quot;manager-status&quot;/&gt;  &lt;role rolename=&quot;admin-gui&quot;/&gt;  &lt;role rolename=&quot;admin-script&quot;/&gt;  &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot;/&gt;</code></pre><p>设置完成之后重启tomcat就可以登录后台管理页面了，其中在manager app中主要管理的是网站是否发布的操作，start&#x3D;发布网站</p><p>stop&#x3D;停止发布网站，reload&#x3D;重新加载，undeploy&#x3D;卸载&#x2F;删除网站（慎用），expire session&#x3D;会话过期时间</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160530000.png" alt="image20200312160956755.png"></p><p>与war文件部署相关的设置，包括定义war文件存放的位置，和上传war文件</p><pre><code>war是一个可以直接运行的web模块，通常用于网站，打包部署。以Tomcat来说，将war包放置在其\webapps\目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了。war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。简单来说，war包是JavaWeb程序打的包，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。</code></pre><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160554207.png" alt="image20200312161045722.png"></p><p>configuration 定义TLS(安全传输协议)配置文件</p><p>diagnostics 检查网站在启动，重新加载或卸载时，是否造成内存溢出，这个操作会触发垃圾回收机制，生产环境中慎用</p><p>TLS connector configuration diagnostics 加密诊断，可以帮助用户诊断加密是否有问题</p><h4 id="②firefox设置中文"><a href="#②firefox设置中文" class="headerlink" title="②firefox设置中文"></a>②firefox设置中文</h4><pre><code>[root@zutuanxue ~]# dnf install ibus* -y</code></pre><p>添加完整的中文环境后重启</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160597852.png" alt="image20200313163452841.png"></p><p>重启完成为浏览器添加中文后重启浏览器</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160616038.png" alt="image20200313163127816.png"></p><p>再次访问tomcat管理界面就会变成中文</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160631864.png" alt="image20200313163617973.png"></p><h4 id="③发布静态页面"><a href="#③发布静态页面" class="headerlink" title="③发布静态页面"></a>③<strong>发布静态页面</strong></h4><pre><code>[root@zutuanxue webapps]# pwd/opt/tomcat1/webapps[root@zutuanxue webapps]# mkdir test[root@zutuanxue webapps]# echo &#39;&lt;%= new java.util.Date() %&gt;&#39;  &gt; test/index.jsp</code></pre><p>使用浏览器访问<a href="http://ip:8080/test,%E6%AF%8F%E6%AC%A1%E5%88%B7%E6%96%B0%E6%97%B6%E9%97%B4%E9%83%BD%E4%BC%9A%E6%94%B9%E5%8F%98">http://ip:8080/test,每次刷新时间都会改变</a></p><h3 id="二、动态页面"><a href="#二、动态页面" class="headerlink" title="二、动态页面"></a>二、动态页面</h3><p>我们知道tomcat是用来发布jsp网站的，jsp的网站，页面漂亮还安全，上节课我们已经知道如何发布静态页面了，本节课我们一起来看一下如何发布动态页面，我们通过jpress一个使用java开发的建站软件来实现jsp页面</p><pre><code>jpress下载地址：http://jpress.io/download</code></pre><p><strong>step 1</strong> 准备jsp页面</p><pre><code>[root@zutuanxue ~]# mv jpress-v3.2.1.war jpress.war[root@zutuanxue ~]# cp jpress.war /opt/tomcat1/webapps/#重启tomcat[root@zutuanxue ~]# cp jpress.war /opt/tomcat1/webapps/[root@zutuanxue ~]# sh /opt/tomcat1/bin/shutdown.sh [root@zutuanxue ~]# sh /opt/tomcat1/bin/startup.sh #重启之后tomcat会自己将这个war的压缩包解压，生成一个同名的目录</code></pre><p><strong>step 2</strong> 准备数据库</p><pre><code>[root@zutuanxue yum.repos.d]# dnf install mariadb mariadb-server -y[root@zutuanxue yum.repos.d]# systemctl restart mariadb.service [root@zutuanxue ~]# mysql -u root -pEnter password: MariaDB [(none)]&gt; create database jpress charset utf8;MariaDB [(none)]&gt; grant all on jpress.* to jpress@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><p><strong>step 3</strong> 安装jpress</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160976235.png" alt="image20200313141545372.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603160997472.png" alt="image20200313141616340.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603161027211.png" alt="image20200313141647962.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603161051771.png" alt="image20200313141659536.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603161069805.png" alt="image20200313141725515.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603161088428.png" alt="image20200313141752995.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603161108200.png" alt="image20200313141822315.png"></p><h2 id="4、多实例"><a href="#4、多实例" class="headerlink" title="4、多实例"></a>4、多实例</h2><p>Tomcat是一个单进程多线程的软件，在很早之前，我们都认为这种模式挺好的，因为早些年的CPU都是单核的，但是现在都是多核心的CPU了,如果还是一个进程的话呢，就比较浪费CPU资源，所以本节课我们要讨论下如果多开几个tomcat，也就是我们本节课要实现的是tomcat的多实例，这样可以提高资源的利用率，在之前的课程中我们提到过tomcat有三个端口8005 8009 8080，其中8005是用来关闭tomcat的端口，8080是访问端口，8009是ajp协议使用的端口，如果我想在一台机器上开启多个tomcat的话，首先要保证的就是端口不能冲突，否则开不了。</p><h3 id="Tomcat多实例实现"><a href="#Tomcat多实例实现" class="headerlink" title="Tomcat多实例实现"></a>Tomcat多实例实现</h3><ul><li>将之前部署好的tomcat复制一份</li></ul><pre><code>[root@zutuanxue webapps]# cd /opt/[root@zutuanxue opt]# lstomcat1[root@zutuanxue opt]# cp -r tomcat1 tomcat2[root@zutuanxue opt]# lstomcat1  tomcat2</code></pre><ul><li>修改刚刚部署完成的tomcat的相关配置文件</li></ul><pre><code>[root@zutuanxue opt]# vim tomcat2/conf/server.xml &lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt;&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8444&quot; /&gt;#修改端口</code></pre><ul><li>启动tomcat</li></ul><pre><code>[root@zutuanxue opt]# sh /opt/tomcat1/bin/startup.sh [root@zutuanxue opt]# sh /opt/tomcat2/bin/startup.sh [root@zutuanxue opt]# netstat -atnpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp6       0      0 127.0.0.1:8005          :::*                    LISTEN      16801/java          tcp6       0      0 127.0.0.1:8006          :::*                    tcp6       0      0 :::8080                 :::*                    LISTEN      16801/java          tcp6       0      0 :::8081                 :::*                    LISTEN      17776/java          </code></pre><ul><li>打开浏览器访问测试</li></ul><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603162375841.png" alt="image20200313144207263.png"><br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603162404686.png" alt="image20200313144222035.png"></p><pre><code>注意：如果是不同用户使用的话，考虑到安全方面的问题，记得修改tomcat的用户管理文件。[root@zutuanxue conf]# pwd/opt/tomcat2/conf[root@zutuanxue conf]# vim tomcat-users.xml &lt;role rolename=&quot;manager-gui&quot;/&gt;  &lt;role rolename=&quot;manager-script&quot;/&gt;  &lt;role rolename=&quot;manager-jmx&quot;/&gt;  &lt;role rolename=&quot;manager-status&quot;/&gt;  &lt;role rolename=&quot;admin-gui&quot;/&gt;  &lt;role rolename=&quot;admin-script&quot;/&gt;  &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot;/&gt;</code></pre><h2 id="5、使用nginx发布tomcat站点"><a href="#5、使用nginx发布tomcat站点" class="headerlink" title="5、使用nginx发布tomcat站点"></a>5、使用nginx发布tomcat站点</h2><p>之前我们在访问的时候使用的都是类似<a href="http://serverip/test%E6%88%96%E8%80%85http://serverip/jpress%E8%BF%99%E7%A7%8D%E5%AD%97%E6%A0%B7%E7%9A%84URL%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E6%AF%94%E8%BE%83%E9%BA%BB%E7%83%A6%EF%BC%8C%E6%89%80%E4%BB%A5%E5%91%A2%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86tomcat%E5%92%8Cnginx%E7%BB%93%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87nginx%E4%BB%A5%E4%B8%8B%E5%8A%9F%E8%83%BD%E5%8F%91%E5%B8%83%EF%BC%9A">http://serverip/test或者http://serverip/jpress这种字样的URL，使用起来比较麻烦，所以呢，我们可以将tomcat和nginx结合在一起，可以通过nginx以下功能发布：</a></p><ul><li>使用nginx url重写</li><li>使用nginx的反向代理功能</li></ul><h3 id="一、部署tomcat网站"><a href="#一、部署tomcat网站" class="headerlink" title="一、部署tomcat网站"></a>一、部署tomcat网站</h3><p>通过部署两个tomcat站点，分别采用nginx url rewrite方法和反向代理发布。</p><ul><li>设置tomcat1</li></ul><pre><code>[root@zutuanxue ~]# cd /opt/tomcat1/webapps/[root@zutuanxue webapps]# mv ROOT tomcat[root@zutuanxue webapps]# mv jpress ROOT</code></pre><ul><li>设置tomcat2</li></ul><pre><code>[root@zutuanxue ~]# cd /opt/tomcat2/webapps/[root@zutuanxue webapps]# mv ROOT tomcat[root@zutuanxue webapps]# mv test ROOT</code></pre><h3 id="二、使用rewrite实现"><a href="#二、使用rewrite实现" class="headerlink" title="二、使用rewrite实现"></a>二、使用rewrite实现</h3><h4 id="2-1、部署nginx"><a href="#2-1、部署nginx" class="headerlink" title="2.1、部署nginx"></a>2.1、部署nginx</h4><pre><code>[root@zutuanxue ~]# dnf install nginx -y</code></pre><h4 id="2-2、设置nginx配置文件"><a href="#2-2、设置nginx配置文件" class="headerlink" title="2.2、设置nginx配置文件"></a>2.2、设置nginx配置文件</h4><pre><code>[root@zutuanxue ~]# vim /etc/nginx/nginx.conf[root@zutuanxue ~]# sed -i &#39;/#/d&#39; /etc/nginx/nginx.conf[root@zutuanxue ~]# sed -i &#39;/^$/d&#39; /etc/nginx/nginx.confserver &#123;        listen       80;        listen       [::]:80;        server_name  www.a.com;        location / &#123;                rewrite ^/$ http://127.0.0.1:8080/jpress break;        &#125;    &#125;    server &#123;        listen       80;        listen       [::]:80;127.0.0.1        server_name  www.b.com;        location / &#123;                rewrite ^/$ http://127.0.0.1:8081/test break;        &#125;    &#125;[root@zutuanxue ~]# systemctl restart nginx</code></pre><h4 id="2-3、修改测试机的hosts文件"><a href="#2-3、修改测试机的hosts文件" class="headerlink" title="2.3、修改测试机的hosts文件"></a>2.3、修改测试机的hosts文件</h4><pre><code>[root@zutuanxue conf]# vim /etc/hosts192.168.98.200  www.a.com192.168.98.200  www.b.com</code></pre><h4 id="2-4、-打开浏览器直接访问域名测试"><a href="#2-4、-打开浏览器直接访问域名测试" class="headerlink" title="2.4、 打开浏览器直接访问域名测试"></a>2.4、 打开浏览器直接访问域名测试</h4><p>测试方法：<br>打开浏览器输入之前设置好的域名<br><a href="http://www.a.com/">http://www.a.com</a><br><a href="http://www.b.com/">http://www.b.com</a><br>查看是否能访问到对应的网站内容，能看到说明实验成功。</p><h3 id="三、使用反向代理实现"><a href="#三、使用反向代理实现" class="headerlink" title="三、使用反向代理实现"></a>三、使用反向代理实现</h3><h4 id="3-1、设置nginx配置文件"><a href="#3-1、设置nginx配置文件" class="headerlink" title="3.1、设置nginx配置文件"></a>3.1、设置nginx配置文件</h4><pre><code>user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123;    worker_connections 1024;&#125;http &#123;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile            on;    tcp_nopush          on;    tcp_nodelay         on;    keepalive_timeout   65;    types_hash_max_size 2048;    include             /etc/nginx/mime.types;    default_type        application/octet-stream;    include /etc/nginx/conf.d/*.conf;    server &#123;        listen       80;        listen       [::]:80;        server_name  www.a.com;        location / &#123;                proxy_pass http://127.0.0.1:8080;        &#125;    &#125;    server &#123;        listen       80;        listen       [::]:80;        server_name  www.b.com;        location / &#123;                proxy_pass http://127.0.0.1:8081;        &#125;    &#125;&#125;</code></pre><h4 id="3-2、打开浏览器直接访问域名测试"><a href="#3-2、打开浏览器直接访问域名测试" class="headerlink" title="3.2、打开浏览器直接访问域名测试"></a>3.2、打开浏览器直接访问域名测试</h4><p>测试方法：<br>打开浏览器输入之前设置好的域名<br><a href="http://www.a.com/">http://www.a.com</a><br><a href="http://www.b.com/">http://www.b.com</a><br>查看是否能访问到对应的网站内容，能看到说明实验成功。</p><h2 id="6、Tomcat调优"><a href="#6、Tomcat调优" class="headerlink" title="6、Tomcat调优"></a>6、Tomcat调优</h2><p>tomcat的优化可以提高网站的并发能力，体现个人的价值，tomcat在java项目中的使用率非常高，所以在生产环境对tomcat的优化也就变得非常必要了，一般情况下tomcat的优化主要从两个方面入手，一个是自身配置，另一个是tomcat所运行的jvm虚拟机的优化，优化的工作可以从安装完tomcat就开始着手</p><h3 id="一、AJP优化"><a href="#一、AJP优化" class="headerlink" title="一、AJP优化"></a>一、AJP优化</h3><p>在前面的课程中我们提到了一个叫AJP的协议，同时我们也知道了这个AJP的作用，但是在生产环境中一般使用的是nginx+tomcat的架构，所以大多数时候用不到AJP协议，所以我们可以禁用它，而在我们的server.xml文件中这个AJP默认就是禁用的,如果是其它版本最好看一下</p><pre><code> [root@zutuanxue conf]# vim /opt/tomcat1/conf/server.xml  &lt;!--    &lt;Connector protocol=&quot;AJP/1.3&quot;               address=&quot;::1&quot;               port=&quot;8009&quot;               redirectPort=&quot;8443&quot; /&gt;    --&gt;</code></pre><h3 id="二、运行模式优化"><a href="#二、运行模式优化" class="headerlink" title="二、运行模式优化"></a>二、运行模式优化</h3><p>tomcat的运行模式有3种：</p><h4 id="bio"><a href="#bio" class="headerlink" title="bio"></a><strong>bio</strong></h4><p>性能非常低下，没有经过任何优化处理和支持，适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><h4 id="nio"><a href="#nio" class="headerlink" title="nio"></a><strong>nio</strong></h4><p>nio(new I&#x2F;O)，是Java SE 1.4及后续版本提供的一种新的I&#x2F;O操作方式它拥有比传统I&#x2F;O操作(bio)更好的并发运行性能。Tomcat9默认使用nio运行模式。适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。AIO(NIO2)使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h4 id="apr"><a href="#apr" class="headerlink" title="apr"></a><strong>apr</strong></h4><p>安装起来最困难，但是从操作系统级别来解决异步的IO问题，大幅度的提高性能</p><p>进入tomcat的服务器状态页面查看默认的模式</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603162047961.png" alt="image20200313202144717.png"></p><p>如果默认使用的是bio模式</p><pre><code>设置使用nio模式[root@zutuanxue logs]# vim /opt/tomcat1/conf/server.xml&lt;Connector  port=&quot;8080&quot;protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;</code></pre><h3 id="apr运行模式"><a href="#apr运行模式" class="headerlink" title="apr运行模式"></a>apr运行模式</h3><p>APR(Apache portable Run-time libraries，Apache可移植运行库)的目的如其名称一样，主要为上层的应用程序提供一个可以跨越多操作系统平台使用的底层支持接口库。可以大大地提高Tomcat对静态文件的处理性能。 也是在Tomcat上运行高并发应用的首选模式。</p><p>系统自带的软件包不是最新的，且缺少相关软件包，所以我们选择源码包安装</p><p>所需软件包</p><p>apr-1.7.0.tar.gz 主程序包 包含了通用开发组件</p><p>apr-iconv-1.2.2.tar.gz 用于实现iconv编码</p><p>apr-util-1.6.1.tar.gz 额外的开发组件</p><p>tomcat-native.tar.gz 关联tomcat和apr的组件</p><p>arp相关软件包下载 <a href="https://mirrors.cnnic.cn/apache/apr/">https://mirrors.cnnic.cn/apache/apr/</a></p><p>tomcat-native在tomcat安装目录的bin下</p><h3 id="部署apr环境"><a href="#部署apr环境" class="headerlink" title="部署apr环境"></a>部署apr环境</h3><p><strong>step 1</strong> 环境准备</p><pre><code>[root@zutuanxue ~]# dnf install -y apr-devel openssl-devel gcc make expat-devel libtool </code></pre><p><strong>step 2</strong> 安装apr主程序包</p><pre><code>[root@zutuanxue ~]# tar fx apr-1.7.0.tar.gz [root@zutuanxue ~]# cd apr-1.7.0/[root@zutuanxue ~]# ./configure --prefix=/usr/local/apr[root@zutuanxue apr-1.7.0]# make -j4 &amp;&amp; make install</code></pre><p><strong>step 3</strong> 安装apr-iconv</p><pre><code>[root@zutuanxue ~]# tar fx apr-iconv-1.2.2.tar.gz [root@zutuanxue ~]# cd apr-iconv-1.2.2/[root@zutuanxue ~]# ./configure   --with-apr=/usr/local/apr  --prefix=/usr/local/apr-iconv[root@zutuanxue apr-iconv-1.2.2]# make -j4 &amp;&amp; make install</code></pre><p><strong>step 4</strong> 安装apr-util</p><pre><code>[root@zutuanxue ~]# tar fx apr-util-1.6.1.tar.gz [root@zutuanxue ~]# cd apr-util-1.6.1/[root@zutuanxue ~]# ./configure --prefix=/usr/local/apr-util  --with-apr=/usr/local/apr   --with-apr-iconv=/usr/local/apr-iconv/bin/apriconv[root@zutuanxue apr-util-1.6.1]# make -j4 &amp;&amp; make install</code></pre><p><strong>step 5</strong> 安装tomcat-native</p><pre><code>[root@zutuanxue ~]# cd /opt/tomcat1/bin/[root@zutuanxue bin]# tar fx tomcat-native.tar.gz [root@zutuanxue bin]# cd tomcat-native-1.2.23-src/native[root@zutuanxue tomcat-native-1.2.23-src]# ./configure --with-apr=/usr/local/apr  --with-java-home=/usr/java/jdk-13.0.2[root@zutuanxue tomcat-native-1.2.23-src]# make -j4 &amp;&amp; make install</code></pre><p><strong>step 6</strong> 修改并加载环境变量</p><pre><code>[root@zutuanxue ~]# echo &#39;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/libexport LD_RUN_PATH=$LD_RUN_PATH:/usr/local/apr/lib&#39; &gt;&gt; /etc/profile[root@zutuanxue ~]# source /etc/profile</code></pre><p><strong>step 7</strong> 修改tomcat配置文件</p><pre><code>[root@zutuanxue ~]# vim /opt/tomcat1/conf/server.xml    protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;</code></pre><p><strong>step 8</strong> 测试</p><pre><code>#为了避免干扰先执行关闭[root@zutuanxue ~]# sh /opt/tomcat1/bin/shutdown.sh #测试[root@zutuanxue ~]# sh /opt/tomcat1/bin/catalina.sh run#如果没有问题可以看到14-Mar-2020 00:22:23.894 信息 [main] org.apache.coyote.AbstractProtocol.start 开始协议处理句柄[&quot;http-apr-8080&quot;]</code></pre><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/20/1603162079362.png" alt="image20200314122328676.png"></p><pre><code>注意：如果非root用户启动失败，把apr环境变量在当前用户的.bash_profile中写一份[root@zutuanxue ~]# echo &#39;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/libexport LD_RUN_PATH=$LD_RUN_PATH:/usr/local/apr/lib&#39; &gt;&gt; /root/.bash_profile[root@zutuanxue ~]# source /root/.bash_profile</code></pre><h3 id="其它优化参数"><a href="#其它优化参数" class="headerlink" title="其它优化参数"></a>其它优化参数</h3><pre><code>[root@zutuanxue logs]# vim /opt/tomcat1/conf/server.xml  &lt;Connector  port=&quot;8080&quot;            protocol=&quot;HTTP/1.1              enableLookups=&quot;false&quot;                maxThreads=&quot;1000&quot;                minSpareThreads=&quot;100&quot;                acceptCount=&quot;900&quot;                disableUploadTimeout=&quot;true&quot;                connectionTimeout=&quot;20000&quot;                URIEncoding=&quot;UTF-8&quot;                redirectPort=&quot;8443&quot;compression=&quot;on&quot;                compressionMinSize=&quot;1024&quot;                useSendfile=&quot;false&quot;                noCompressionUserAgents=&quot;mozilla, traviata&quot;                compressibleMimeType=&quot;text/html,text/xml,text/plain,text/css,text/javascript,application/javascript &quot;  /&gt;maxThreads：最大线程数，默认150。增大值避免队列请求过多，导致响应缓慢。minSpareThreads：最小空闲线程数。acceptCount：当处理请求超过此值时，将后来请求放到队列中等待。disableUploadTimeout：禁用上传超时时间connectionTimeout：连接超时，单位毫秒，0代表不限制URIEncoding：URI地址编码使用UTF-8enableLookups：关闭dns解析，提高响应时间compression：启用压缩功能compressionMinSize：最小压缩大小，单位BytecompressibleMimeType ：压缩的文件类型官方参数文档：http://tomcat.apache.org/tomcat-9.0-doc/config/http.html</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本</title>
      <link href="/2023/09/26/shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/09/26/shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h1><h2 id="一、变量介绍"><a href="#一、变量介绍" class="headerlink" title="一、变量介绍"></a>一、变量介绍</h2><p>在编程中，我们总有一些数据需要临时存放在内存，以待后续使用时快速读出。先了解一下计算机的存储单位吧。</p><pre><code>计算机的单位:1B=8bit1KB=1024B1MB=1024KB1GB=1024MB1TB=1024GB1PB=1024TB1EB=1024PB1ZB=1024EB...好了，已经够大了！当然还有YB、BB更大的单位，同样进制也是1024.1G=1024*1024*1024=1073741824B</code></pre><p>假如你将一个1B的字符存入内存，如何读出呢？有没有一种大海捞针的感觉啊！我们讨论一下计算机是如何通过让我们人类快速将数据存在内存，如何从内存中读出数据的。我们研究过变量后就明白了。</p><p>变量：变量是编程中最常用的一种临时在内存中存取数据的一种方式。</p><p>变量存取原理</p><pre><code>关于内存的说明a、系统启动    内存被按照1B一个单位划分成N块     并且以十六进制为每一个空间编号b、内存跟踪表记录  使用和未使用的内存的地址编号c、内存申请    系统从未使用的内存中拿出一个或者一段连续空间  给你使用   同时在内存跟踪表中记录该地址被占用不在分给别人，同时在系统中建立映射机制   比如:变量名 STRING1=‘ABC’name&lt;==&gt;0x5d、释放内存从内存跟踪表中将记录删除，下次存数据直接覆盖</code></pre><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/9/21/1600685218168.png" alt="变量存储.png"></p><pre><code>CHAR1(0x3)=A从图片可以看出，当我们在脚本中定义变量存值的时候，可以从以下方面看到变化：a、内存占用：如果存的是一个字符则占用1个字节，如果存的是字符串则是字符串的长度加1个字节长度(\0是一个特殊字符，代表字符串结束)。b、变量名与内存空间关系：计算机中会将对应的内存空间地址和变量名称绑定在一起，此时代表这段内存空间已经被程序占用，其他程序不可复用；然后将变量名对应的值存在对应内存地址的空间里。</code></pre><h2 id="二、变量定义"><a href="#二、变量定义" class="headerlink" title="二、变量定义"></a>二、变量定义</h2><h3 id="2-1-什么时候需要定义变量？"><a href="#2-1-什么时候需要定义变量？" class="headerlink" title="2.1 什么时候需要定义变量？"></a>2.1 什么时候需要定义变量？</h3><p>如果某个内容需要多次使用，并且在代码中重复出现，那么可以用变量代表该内容。这样在修改内容的时候，仅仅需要修改变量的值。<br>在代码运作的过程中，可能会把某些命令的执行结果保存起来，后续代码需要使用这些结果，就可以直接使用这个变量。</p><h3 id="2-2-定义一个变量"><a href="#2-2-定义一个变量" class="headerlink" title="2.2 定义一个变量"></a>2.2 定义一个变量</h3><p>变量格式： 变量名&#x3D;值</p><p>在shell编程中的变量名和等号之间不能有空格。</p><pre><code>变量名命名规则：    命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。    中间不能有空格，可以使用下划线（_）。    不能使用标点符号。    不能使用bash里的关键字（可用help命令查看保留关键字）。</code></pre><p>定义变量举例：<br>VAR1&#x3D;1<br>age&#x3D;18 整形<br>name&#x3D;‘baism’ 字符串<br>score&#x3D;88.8 浮点</p><pre><code>注意：字符串要用单引号或双引号引起来建议变量名为大写，和命令区分            _name</code></pre><p>定义变量演示：</p><pre><code>变量赋值，此种方法设置为本地变量[root@zutuanxue ~]# name=&quot;baism&quot;[root@zutuanxue ~]# school=&#39;ayitula&#39;[root@zutuanxue ~]# age=30[root@zutuanxue ~]# score=88.8</code></pre><h3 id="2-3-取消变量-unset"><a href="#2-3-取消变量-unset" class="headerlink" title="2.3 取消变量 unset"></a>2.3 取消变量 unset</h3><pre><code>取消当前环境中的变量，如果是变量设置是保存在文件中，下次重启又会恢复[root@zutuanxue ~]# unset name[root@zutuanxue ~]# echo $name</code></pre><h3 id="2-4-有类型变量-declare"><a href="#2-4-有类型变量-declare" class="headerlink" title="2.4 有类型变量 declare"></a>2.4 有类型变量 declare</h3><p>-i 将变量看成整数<br>-r 使变量只读 readonly,该变量的值无法改变，并且不能为unset<br>-x 标记变量通过环境导出 export<br>-a 指定为索引数组（普通数组）；查看普通数组<br>-A 指定为关联数组；查看关联数组</p><pre><code>[root@zutuanxue ~]# declare -i num=&#39;asa&#39;[root@zutuanxue ~]# echo $num0[root@zutuanxue ~]# num=100[root@zutuanxue ~]# echo $num100[root@zutuanxue ~]# declare -r num[root@zutuanxue ~]# echo $num100[root@zutuanxue~]# num=200-bash: num: 只读变量[root@zutuanxue ~]# declare -xdeclare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/root&quot;declare -x HOSTNAME=&quot;Bai_Shuming&quot;declare -x LANG=&quot;zh_CN.UTF-8&quot;declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;</code></pre><h2 id="三、变量分类"><a href="#三、变量分类" class="headerlink" title="三、变量分类"></a>三、变量分类</h2><p>系统中的变量根据作用域及生命周期可以分为四类：本地变量、环境变量、全局变量、内置变量</p><h3 id="3-1-本地变量"><a href="#3-1-本地变量" class="headerlink" title="3.1 本地变量"></a>3.1 本地变量</h3><p>用户自定义的变量，定义在脚本或者当前终端中，脚本执行完毕或终端结束变量失效。</p><h3 id="3-2-环境变量"><a href="#3-2-环境变量" class="headerlink" title="3.2 环境变量"></a>3.2 环境变量</h3><p>定义在用户家目录下的.bashrc或.bash_profile文件中，用户私有变量，只能本用户使用。</p><p>查看当前用户的环境变量 env</p><p>查询当前用户的所有变量(临时变量与环境变量) set</p><h3 id="3-3-将当前变量变成环境变量-export"><a href="#3-3-将当前变量变成环境变量-export" class="headerlink" title="3.3 将当前变量变成环境变量 export"></a>3.3 将当前变量变成环境变量 export</h3><pre><code>定义一个临时变量1、[root@zutuanxue tmp]# export A=hello //临时将一个本地变量（临时变量）变成环境变量[root@zutuanxue tmp]# env|grep ^AA=hello2、[root@zutuanxue tmp]# A=HELLO[root@zutuanxue tmp]# export A3、定义一个永久生效变量：vim .bash_profile 或者 ~/.bashrcA=hello关于export说明用户登录时:1) 用户登录到Linux系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行 shell脚本程序。运行脚本时:2) 运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建的shell。当一个脚本程序运行完毕，它的脚本shell将终止，可以返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多 shell，每个shell都是由某个shell（称为父shell）派生的。在子shell中定义的变量只在该子shell内有效。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，要使某个变量的值可以在其他shell中被改变，可以使用export命令对已定义的变量进行输出。 export命令将使系统在创建每一个新的shell时定义这个变量的一个拷贝。这个过程称之为变量输出。</code></pre><p>父shell与子shell</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/9/21/1600685550727.png" alt="shell父子关系.png"></p><h3 id="3-4-全局变量"><a href="#3-4-全局变量" class="headerlink" title="3.4 全局变量"></a>3.4 全局变量</h3><p>使用export命令将本地变量输出为当前shell中的环境变量<br>所有用户及shell都可以使用，可以在&#x2F;etc&#x2F;profile &#x2F;etc&#x2F;bashrc下永久定义</p><pre><code>打印全局变量 printenv定义格式export SCHOOL=&#39;zutuanxue&#39;测试方法：通过不同用户登录测试是否能读取变量</code></pre><h3 id="3-5-内置变量"><a href="#3-5-内置变量" class="headerlink" title="3.5 内置变量"></a>3.5 内置变量</h3><p>系统变量(内置bash中变量) ： shell本身已经固定好了它的名字和作用.</p><pre><code>$?：上一条命令执行后返回的状态，当返回状态值为0时表示执行正常，非0值表示执行异常或出错 若退出状态值为0，表示命令运行成功 若退出状态值为127,表示command not found 若退出状态值为126,表示找到了该命令但无法执行（权限不够） 若退出状态值为1&amp;2,表示没有那个文件或目录 $$：当前所在进程的进程号     echo $$   eg：kill -9 `echo $$`  = exit   退出当前会话$!：后台运行的最后一个进程号  （当前终端）  # gedit &amp;!$ 调用最后一条命令历史中的参数!! 调用最后一条命令历史$#：脚本后面接的参数的个数$*：脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开$@: 脚本后面所有参数，参数是独立的，也是全部输出$0：当前执行的进程/程序名  echo $0     $1~$9 位置参数变量$&#123;10&#125;~$&#123;n&#125; 扩展位置参数变量  第10个位置变量必须用&#123;&#125;大括号括起来./1.sh a b c[root@zutuanxue shell01]# cat 2.sh #!/bin/bash#xxxxecho &quot;\$0 = $0&quot;echo &quot;\$# = $#&quot;echo &quot;\$* = $*&quot;echo &quot;\$@ = $@&quot;echo &quot;\$1 = $1&quot; echo &quot;\$2 = $2&quot; echo &quot;\$3 = $3&quot; echo &quot;\$11 = $&#123;11&#125;&quot; echo &quot;\$12 = $&#123;12&#125;&quot; 了解$*和$@的区别：$* :表示将变量看成一个整体$@ :表示变量是独立的#!/bin/bashfor i in &quot;$@&quot;doecho $idoneecho &quot;======我是分割线=======&quot;for i in &quot;$*&quot;doecho $idone[root@zutuanxue shell01]# bash 3.sh a b cabc======我是分割线=======a b c</code></pre><p>变量总结说明：</p><p>本地变量：当前用户自定义的变量。当前进程中有效，其他进程及当前进程的子进程无效。</p><p>环境变量：当前进程有效，并且能够被子进程调用。</p><p>全局变量：全局所有的用户和程序都能调用，且继承，新建的用户也默认能调用.</p><p>内置变量：shell本身已经固定好了它的名字和作用.</p><table><thead><tr><th>变量类型</th><th>作用域</th><th>生命周期</th></tr></thead><tbody><tr><td>本地变量</td><td>当前shell环境(子shell不能用)</td><td>脚本结束或终端结束</td></tr><tr><td>环境变量</td><td>当前shell或者子shell</td><td>当前进程结束</td></tr><tr><td>全局变量</td><td>所有用户及shell环境</td><td>关机</td></tr><tr><td>内置变量</td><td>所有用户及shell环境</td><td>关机</td></tr></tbody></table><h2 id="四、变量取值"><a href="#四、变量取值" class="headerlink" title="四、变量取值"></a>四、变量取值</h2><p>读取变量内容符: 读取方法：变量名</p><pre><code>变量内容读出[root@zutuanxue ~]# echo $namebaism[root@zutuanxue ~]# echo $schoolayitula[root@zutuanxue ~]# echo $age30[root@zutuanxue ~]# echo $score88.8</code></pre><p><strong>注意</strong></p><pre><code>变量读取过程中，默认单引号是不解释变量的.比如[root@zutuanxue ~]# echo &#39;$name&#39;$name如果必须使用单引号还要读取变量的值可以使用eval命令[重新运算求出参数的内容] [root@zutuanxue ~]# eval  echo &#39;$name&#39;baism</code></pre><h2 id="五、其他变量（扩展）"><a href="#五、其他变量（扩展）" class="headerlink" title="五、其他变量（扩展）"></a>五、其他变量（扩展）</h2><pre><code>1）取出一个目录下的目录和文件：dirname和 basename 2）变量&quot;内容&quot;的删除和替换一个“%”代表从右往左去掉一个/key/两个“%%”代表从右往左最大去掉/key/一个“#”代表从左往右去掉一个/key/两个“##”代表从左往右最大去掉/key/# A=/root/Desktop/shell/mem.txt # echo $A/root/Desktop/shell/mem.txt# dirname $A   取出目录/root/Desktop/shell# basename $A  取出文件mem.txt# url=www.taobao.com# echo $</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本优化</title>
      <link href="/2023/09/26/Linux%E5%9F%BA%E6%9C%AC%E4%BC%98%E5%8C%96/"/>
      <url>/2023/09/26/Linux%E5%9F%BA%E6%9C%AC%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="一、selinux和防火墙优化"><a href="#一、selinux和防火墙优化" class="headerlink" title="一、selinux和防火墙优化"></a>一、selinux和防火墙优化</h2><h3 id="1、SElinux"><a href="#1、SElinux" class="headerlink" title="1、SElinux"></a>1、SElinux</h3><p>selinux 安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要由美国国家安全局开发。它的主要 作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。也由于它的这个原则，导致我们很多操作无法正确的执行，所以对于初学者而言在会用selinux之前我们要把这个子系统关闭</p><p><strong>SELinux 的工作模式</strong></p><p>SELinux 有三种工作模式，分别是：</p><pre><code>- enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。- permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。- disabled：关闭 SELinux。</code></pre><p><strong>SElinux工作模式设置方法</strong></p><ul><li>临时设置<br>enforcing 和 permissive 模式可以通过 setenforce 1|0 命令快速切换,重启系统后失效。</li><li>永久生效<br>SELinux 工作模式可以在 &#x2F;etc&#x2F;selinux&#x2F;config 中设定。</li></ul><pre><code>如果想从 disabled 切换到 enforcing 或者 permissive 的话，需要重启系统。反过来也一样。</code></pre><p>需要注意的是，如果系统已经在关闭 SELinux 的状态下运行了一段时间，在打开 SELinux 之后的第一次重启速度可能会比较慢。因为系统必须为磁盘中的文件创建安全上下文，我们现在来看一下如何关闭selinux，首先用root的身份登录系统，打开一个终端输入gedit &#x2F;etc&#x2F;selinux&#x2F;config命令，回车之后会打开一个文件，将所标记出来部分的enforcing改为disabled，保存之后重启linux系统</p><pre><code>[root@zutuanxue ~]# gedit /etc/selinux/config##/etc/selinux/config  内容# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:#     enforcing - SELinux security policy is enforced.#     permissive - SELinux prints warnings instead of enforcing.#     disabled - No SELinux policy is loaded.SELINUX=enforcing     #这里定义selinux是否为开启状态# SELINUXTYPE= can take one of these three values:#     targeted - Targeted processes are protected,#     minimum - Modification of targeted policy. Only selected processes are protected. #     mls - Multi Level Security protection.SELINUXTYPE=targeted   #这里定义的是selinux保护级别</code></pre><p>重启登录之后可以使用sestatus -v命令去查看是否成功，如果看到的状态不是disabled则需要重新操作</p><pre><code>[root@zutuanxue ~]# sestatus -vSELinux status:                 disabled</code></pre><h3 id="2、防火墙"><a href="#2、防火墙" class="headerlink" title="2、防火墙"></a>2、防火墙</h3><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。 在CentOS8中使用firewalld作为防火墙，基于iptables的防火墙被默认不启动，但仍然可以继续使用。CentOS8中有几种防火墙共存：firewalld、iptables、ebtables等，默认使用firewalld作为防火墙，通过firewall-cmd工具来管理netfilter,不过底层调用的命令仍然是iptables，虽然防火墙是安全软件，但是它的一些默认设置会对初学者造成困扰，所以我们要先关闭firewalld。通过systemctl stop firewalld.service停止防火墙，systemctl disable firewalld.service禁止防火墙服务开机启动，接下来我们看一下如何设置中文</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389727708.png" alt="1571044294838.png"></p><h2 id="二、中文设置优化"><a href="#二、中文设置优化" class="headerlink" title="二、中文设置优化"></a>二、中文设置优化</h2><p>我们在安装系统选择的是中文，但是我们系统当中并没有中文输入法，所以如果要想输入中文的话需要添加中文输入法，以root用户身份登录系统之后我们使用gedit &#x2F;etc&#x2F;yum.repos.d&#x2F;server.repo,输入如下内容保存退出，确保虚拟机的光驱中加载的是CentOS8的光盘镜像，并且已连接<br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389773586.png" alt="1571048414719.png"><br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389785159.png" alt="1571047694890.png"></p><p>设置完成之后执行mkdir命令建立目录，然后挂载光盘</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389813049.png" alt="1571047821170.png"></p><p>光盘挂载完成之后执行输入法安装命令，如果只要拼音则安装的是： ibus-libpinyin.x86_64</p><pre><code># 安装所有支持的输入法[root@zutuanxue ~]# dnf install ibus* -y# 或者 精准安装拼音输入法[root@zutuanxue ~]#  dnf install ibus-libpinyin.x86_64 -y</code></pre><p>等待软件包安装完成之后重启系统然后重新登录</p><pre><code>如果不想重启系统可以使用[root@zutuanxue ~]# ibus restart 命令重启ibus-daemon进程来实现</code></pre><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389829983.png" alt="1571048752409.png"></p><p>安装完成之后点击右上角的按钮然后点击设置</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389850869.png" alt="1571048826875.png"></p><p>在新打开的窗口中找到语言，选择添加，选择汉语，然后选择一个适合自己的中文输入法点击添加之后就可以使用中文输入法了</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389866470.png" alt="1571048904227.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389893147.png" alt="1571049215146.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389909572.png" alt="1571049244944.png"></p><p>输入法设置完成之后，我们来看下时间相关的设置</p><h2 id="三、网络时间服务器优化"><a href="#三、网络时间服务器优化" class="headerlink" title="三、网络时间服务器优化"></a>三、网络时间服务器优化</h2><p>如果系统的时间不准，自己手动设置起来比较麻烦，我们可以看下怎么来优化一下</p><p>同样还是找到设置，在里面找到详细信息，展开之后可以看到日期和时间的设置，两个自动设置的选项打开，如果你的虚拟机可以联网的话，过一会就会看到时间正常了</p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389925235.png" alt="1571049564017.png"></p><p><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389936841.png" alt="1571049605979.png"><br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389949009.png" alt="1571049727212.png"></p><h2 id="四、自启动服务优化"><a href="#四、自启动服务优化" class="headerlink" title="四、自启动服务优化"></a>四、自启动服务优化</h2><p>自启动服务优化的方式类似我们之前提到的停止firewalld，但是首先我们要确认一下有哪些服务是开机启动的，然后利用之前用过的systemctl stop servername和systemctl disabled servername这两条命令停止相应的服务，比如说蓝牙服务和防火墙服务，但是各位需要注意的是，这里面所涉及的服务在你不了解的前提下不要乱停止，否则可能会导致系统功能失灵，甚至是崩溃<br><img src="https://www.zutuanxue.com:8000/static/media/images/2020/10/11/1602389969693.png" alt="1571050099841.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令与符号</title>
      <link href="/2023/09/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/2023/09/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常用命令介绍"><a href="#一、常用命令介绍" class="headerlink" title="一、常用命令介绍"></a>一、常用命令介绍</h2><p>在linux系统中存在很多命令，这些命令可以帮助我们完成不同的工作，在这里面我们先介绍一些常用的基础命令，这些命令可以帮助我们完成对应的基本操作，随着以后的学习，我们还会接触到更多可以帮助我们完成不同工作的linux命令，我们来一起看一下这些基础命令都有哪些</p><p><strong>1、关机、重启命令</strong></p><p><strong>关机命令</strong></p><ul><li>init 0 #管理员可以使用</li><li>halt</li><li>shutdown -h</li><li>poweroff</li></ul><p><strong>重启命令</strong></p><ul><li>shutdown -r</li><li>reboot</li><li>shutdown -r</li></ul><p>强烈推荐：关机或重启命令及步骤</p><pre><code>1） sync：将缓冲区的数据同步到磁盘中(关机，重启前都需要执行，避免数据丢失)，在Linux系统中，当数据需要存入磁盘时，通常会先放到缓冲区内，等到适当的时刻再写入磁盘，如此可提高系统的执行效率2） shutdown： 以一种安全的方式关闭或重启系统。所有登陆用户都可以看到关机信息提示，并且禁止登陆    -k并非真正关机，只向所有人显示警告信息。        如：shutdown -k +5    -r重启。默认延迟一分钟        如：shutdown -r +3 &quot;shutdown in 3 minutes&quot;    -h关机。默认延迟一分钟        如：shutdown -h 12：00/shutdown -h now    -f重启时跳过磁盘检测。    -F重启时强制磁盘检测。    -c取消shutdown推荐理由：1、将内存中的数据刷入硬盘，避免因为重启或关机数据没有及时保存而丢失2、避免多用户使用突然某个用户强行关机，影响其他用户，使用shutdown关机和重启可以通知其他用户，给予缓冲时间</code></pre><p><strong>2、系统信息</strong></p><ul><li>uname</li></ul><pre><code>-s  输出内核名称-n  输出网络节点上的主机名-r  输出内核发行号-v  输出内核版本-m  输出主机的硬件架构名称-p  输出处理器类型或&quot;unknown&quot;-i输出硬件平台或&quot;unknown&quot;-o输出操作系统名称-a  以如下次序输出所有信息。其中若-p和-i的结果不可知则省略</code></pre><ul><li>hostname 查看主机名</li></ul><pre><code># hostnamectl set-hostname hello</code></pre><ul><li>date 查看和设置时间</li></ul><pre><code>时间方面：%n : 下一行%t : 跳格 tab%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..60)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区日期方面：%a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (yyyy-mm-dd)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)[root@zutuanxue ~]# date &#39;+%I%M%S&#39;025929[root@zutuanxue ~]# date &#39;+%r&#39;上午 02时59分49秒[root@zutuanxue ~]# date &#39;+%s&#39;1584428402[root@zutuanxue ~]# date &#39;+%Z&#39;EDT[root@zutuanxue ~]# date &#39;+%a&#39;二[root@zutuanxue ~]# date &#39;+%A&#39;星期二[root@zutuanxue ~]# date &#39;+%b&#39;3月[root@zutuanxue ~]# date &#39;+%B&#39;三月[root@zutuanxue ~]# date &#39;+%c&#39;2020年03月17日 星期二 03时01分36秒[root@zutuanxue ~]# date &#39;+%T%n%D&#39;03:03:3503/17/20[root@zutuanxue ~]# date &#39;+%T%t%D&#39;03:03:5803/17/20[root@zutuanxue ~]# date -s 2021-10-252021年 10月 25日 星期一 00:00:00 EDT[root@zutuanxue ~]# date -s 18:002021年 10月 25日 星期一 18:00:00 EDT[root@zutuanxue ~]# date -s 18:30:212021年 10月 25日 星期一 18:30:21 EDT[root@zutuanxue ~]# date -s &quot;2021-04-28 15:30:20&quot;2021年 04月 28日 星期三 15:30:20 EDT</code></pre><p><strong>3、文件和目录</strong></p><ul><li>cd 目录 进入目录</li><li>pwd： 查看当前的工作路径</li></ul><pre><code>-P显示实际位置-L显示所在位置[root@zutuanxue ~]# cd /etc     #进入到/etc这个目录[root@zutuanxue ~]# cd /[root@zutuanxue /]# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@zutuanxue /]# cd bin/[root@zutuanxue bin]# pwd/bin[root@zutuanxue bin]# pwd -P/usr/bin[root@zutuanxue bin]# pwd -L/bin</code></pre><ul><li>ls： 查看当前目录下有哪些文件</li></ul><pre><code>-a 列出目录下的所有文件，包括以 . 开头的隐含文件。-A 显示除 “.”和“..”外的所有文件。-B 不输出以 “~”结尾的备份文件。-c 与lt一起使用，显示并按照修改时间（ctime）排序，与l一起使用，显示修改时间，按名称排序。-d 将目录象文件一样显示，而不是显示其下的文件。-f 对输出的文件不排序，使用此选项后aU选项生效，lst选项失效-F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。-g 类似l但是不显示所有者-h 与l一起，以易于阅读的格式输出文件大小(例如 1K 234M 2G)-i 输出文件的i节点的索引信息。-k 以k字节的形式表示文件的大小。--si类似k但是以1000为进制而非1024-l 列出文件的详细信息。-L 遇到链接文件是，显示原文件的信息，而非链接信息-m 横向输出文件名，并以“，”作分格符。-n 类似l,但是用数字的 UID,GID 代替名称。-o 显示文件的除组信息外的详细信息。-p 目录后面加上/标识-q 用?代替不可输出的字符。-r 对目录反向排序。-s 在每个文件名后输出该文件的大小。-t 以修改时间排序。-u 与lt一起使用，以访问时间(atime)排序；与l一起使用显示访问时间，按照名称排序-x 按列输出，横向排序。-Q 把输出的文件名用双引号括起来。-R 列出所有子目录下的文件。-S 以文件大小排序。-X 以文件的扩展名(最后一个 . 后的字符)排序。-1 一行只输出一个文件。--color=no 不显示彩色文件名--help 在标准输出上显示帮助信息。--version 在标准输出上输出版本信息并退出。</code></pre><ul><li>mkdir 建立目录</li></ul><pre><code>-m设置权限模式(类似chmod)-p需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理-v每次创建新目录都显示信息-Z将每个创建的目录的SELinux 安全环境设置为CTX</code></pre><ul><li>rmdir 删除空文件夹</li></ul><pre><code>-p  递归删除空目录，从最后一个目录倒删</code></pre><ul><li>touch 建立文件</li></ul><pre><code>-a只更改访问时间-c不创建任何文件-m只更改修改时间-r使用指定文件的时间属性替代当前时间-t使用[[CC]YY]MMDDhhmm[.ss] 格式的时间替代当前时间[root@zutuanxue ~]# stat hello  文件：hello  大小：0         块：0          IO 块：4096   普通空文件设备：fd00h/64768dInode：34502264    硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-03-17 16:51:35.502961371 -0400最近更改：2020-03-17 16:51:35.502961371 -0400最近改动：2020-03-17 16:51:35.502961371 -0400创建时间：-[root@zutuanxue ~]# touch -a -t 202002010101.30 hello[root@zutuanxue ~]# stat hello  文件：hello  大小：0         块：0          IO 块：4096   普通空文件设备：fd00h/64768dInode：34502264    硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-02-01 01:01:30.000000000 -0500最近更改：2020-03-17 16:51:35.502961371 -0400最近改动：2020-03-17 16:51:53.143475189 -0400创建时间：-[root@zutuanxue ~]# touch -m -t 202002050101.30 hello[root@zutuanxue ~]# stat hello  文件：hello  大小：0         块：0          IO 块：4096   普通空文件设备：fd00h/64768dInode：34502264    硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-02-01 01:01:30.000000000 -0500最近更改：2020-02-05 01:01:30.000000000 -0500最近改动：2020-03-17 16:52:07.837453512 -0400创建时间：-#将hello-linux.txt的属性改成与anaconda-ks.cfg一样[root@zutuanxue ~]# stat hello-linux.txt   文件：hello-linux.txt  大小：12        块：8          IO 块：4096   普通文件设备：fd00h/64768dInode：34513350    硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-03-17 22:50:51.319377144 -0400最近更改：2020-03-17 22:50:45.909483733 -0400最近改动：2020-03-17 22:50:45.912483674 -0400创建时间：-[root@zutuanxue ~]# stat anaconda-ks.cfg   文件：anaconda-ks.cfg  大小：1378      块：8          IO 块：4096   普通文件设备：fd00h/64768dInode：34973658    硬链接：1权限：(0600/-rw-------)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-03-16 23:08:34.121427663 -0400最近更改：2020-02-04 15:01:33.273959663 -0500最近改动：2020-03-18 16:33:48.873881970 -0400创建时间：-[root@zutuanxue ~]# touch -r anaconda-ks.cfg hello-linux.txt [root@zutuanxue ~]# stat hello-linux.txt   文件：hello-linux.txt  大小：12        块：8          IO 块：4096   普通文件设备：fd00h/64768dInode：34513350    硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-03-16 23:08:34.121427663 -0400最近更改：2020-02-04 15:01:33.273959663 -0500最近改动：2020-03-18 18:22:48.694597233 -0400创建时间：-</code></pre><ul><li>cat 查看文件内容</li></ul><pre><code>-A等价于-vET-b对非空输出行编号-e      等价于-vE-E在每行结束处显示$-n对输出的所有行编号-s不输出多行空行-t与-vT等价-T将跳格字符（tab）显示为 ^I-v使用^和M</code></pre><ul><li>rm 删除文件或目录</li></ul><pre><code>-f强制删除。忽略不存在的文件，不提示确认-i在删除前需要确认-I超过三个文件或者递归删除前要求确认。比-i提示内容更少-d删除空目录-r递归删除目录及其内容</code></pre><p>这些命令都是初学者可能会经常用到的，大家可以在自己的虚拟机上练习一下</p><ul><li>cp 拷贝</li></ul><pre><code>-i覆盖前询问(使前面的 -n 选项失效)-n不要覆盖已存在的文件(使前面的 -i 选项失效)-R, -r, --recursive递归复制目录及其子目录内的所有内容-s只创建符号链接而不复制文件-f强制，将目标文件无法打开则将其移除并重试</code></pre><ul><li>mv 移动&#x2F;改名</li></ul><pre><code>-f覆盖前不询问-i覆盖前询问-n不覆盖已存在文件#如果您指定了-i、-f、-n 中的多个，仅最后一个生效。</code></pre><h2 id="二、常用符号"><a href="#二、常用符号" class="headerlink" title="二、常用符号"></a>二、常用符号</h2><pre><code>*任意字符串?任意字符/路径间隔符~当前用户的家目录管理员家目录为/root，其它用户的家目录在/home/用户名</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
